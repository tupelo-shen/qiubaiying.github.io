---
layout:     post
title:      Linux内核34-读/写信号量
subtitle:   Linux-读/写信号量的工作原理以及实现机制
date:       2020-04-13
author:     Tupelo Shen
header-img: img/post-bg-unix-linux.jpg
catalog:    true
tags:
    - Linux
    - Linux内核
    - 读/写信号量
    - rw_semaphore
---

每一种技术的出现必然是因为某种需求。正因为人的本性是贪婪的，所以科技的创新才能日新月异。

# 读/写信号量的工作原理

读/写信号量和读/写自旋锁类似，不同的地方是进程在等待读/写信号量的时候处于挂起状态，而在等待读/写自旋锁的时候是处于忙等待，也就是自旋的状态中。

那也就是说，读/写信号量同读/写自旋锁一样，对于读操作，多个内核控制路径可以并发请求一个读写信号量；而对于写操作，每个内核控制路径必须独占访问受保护的资源。因此，对于读/写信号量来说，写操作的时候，既不可以进行读操作，也不可以进行写操作。读/写信号量提高了内核中的并发数量，也同时提高了系统的整体性能。

内核严格按照先进先出（FIFO）的原则处理等待读/写信号量的进程。读进程或者写进程一旦请求信号量失败，就被写到信号量等待队列的队尾。当信号量被释放后，队列中的第一个进程先被执行，因为它先被唤醒。如果唤醒的是一个写进程，那么队列中其它进程继续休眠。如果唤醒的是一个读进程，写进程之前的所有读进程都会被唤醒获得信号量；但是写进程之后的读进程继续休眠。

# 读/写信号量的数据结构

读/写信号量使用数据结构`rw_semaphore`表示，其成员为：

* count

    一个32位的整形数，被分割成两个16位的计数器。高16位的计数器以2的补码形式表示非等待写进程和等待内核控制路径的数量，低16位表示非等待读进程和非等待写进程的总数。

* wait_list

    等待进程的列表。每个元素是一个`rwsem_waiter`数据结构，包含指向休眠进程描述符的指针和一个标志，这个标志表明进程申请信号量是要读取还是写入。

* wait_lock

    自旋锁，用来保护等待队列和`rw_semaphore`数据结构。

# 读/写信号量的有关API

初始化函数为 `init_rwsem()`，用其可以初始化一个`rw_semaphore`数据结构，将count设为0，wait_lock自旋锁设为未使用，wait_list设为空列表。

`down_read()` 和 `down_write()`函数分别用来请求读信号量和写信号量。同理，`up_read()`和 `up_write()`函数分别用来释放读信号量和写信号量。`down_read_trylock()`和`down_write_trylock()`函数分别与`down_read()` 和 `down_write()`函数类似，只是当信号量忙的时候不会阻塞进程。最后，还有一个重要的函数，`downgrade_write()`，用于写进程使用完写信号量之后，自动将其转换成一个读信号量。这些函数的实现与普通信号量的实现极其类似，所以，在此，我们就不再详细描述其实现过程了。