---
layout:     post
title:      Linux内核31-Seqlock
subtitle:   Linux-Seqlock锁工作原理以及应用场合
date:       2020-04-12
author:     Tupelo Shen
header-img: img/post-bg-unix-linux.jpg
catalog:    true
tags:
    - Linux
    - Linux内核
    - Seqlock
---

# 1 什么是seqlock锁？

上一篇文章中，我们已经学习了读/写自旋锁的工作原理和实现方式（基于ARM架构体系）。但是，有一个问题我们不得不考虑，那就是read锁和write锁的优先级问题：它们具有相同的优先级，所以，读操作必须等到写操作完成后才能执行，同样，写操作必须等到读操作完成后才能执行。

Linux2.6内核版本引入了`Seqlock`锁，与读写自旋锁基本一样，只是对于写操作来说，具有更高的优先级；也就是说，即使现在读操作正在执行，写操作也会被立即执行。这个策略的优点就是，写操作绝不会等待（除非是有其它写操作在占用锁）；缺点就是，读操作可能需要读取多次，才能获取正确的备份。

# 2 seqlock锁实现

`seqlock`锁的数据结构如下所示，包含两个数据成员`lock`和`seqcount`。查看代码可知，`seqlock`锁就是一个自旋锁加上一个序列计数器。

    typedef struct {
        struct seqcount seqcount;       // 序列计数器
        spinlock_t lock;
    } seqlock_t;

`seqlock`锁的工作原理是，对于读操作而言，每次读取数据前后，都要读取序列计数器2次，检查这前后两次的值是否一致，一致则认为可以使用锁。相反，如果一个新的写操作开始工作，增加序列计数器的值，隐含地告知读操作刚刚读到的数据不合法，需要重新读取数据。

`seqlock_t`类型变量初始化的方法有两种：一种是直接赋值`SEQLOCK_UNLOCKED`，另外一种是调用`seqlock_init`宏。写操作分别申请锁和释放锁，分别调用`write_seqlock()`和`write_sequnlock()`。申请锁的过程是，申请`seqlock_t`数据结构中的自旋锁，并对序列计数器进行加一操作。释放锁的过程是，再一次对序列计数器进行加一操作，并释放掉自旋锁。这样操作的结果就是，写操作过程中，计数器的计数是奇数；没有写操作的时候，计数器是偶数。

# 3 seqlock锁使用范例

对于读操作来说，大概的代码实现如下所示：

        unsigned int seq;
        do {
            seq = read_seqbegin(&seqlock);
            /* ... 临界代码段 ... */
        } while (read_seqretry(&seqlock, seq));

`read_seqbegin()`获取锁的当前序列号。`read_seqretry()`判断序列号是否一致，如果seq的值是奇数，则会返回1，也就是条件为真（也就是说，`read_seqbegin()`函数被调用之后，有写操作更新了数据）。因此，需要重新读取数据。如果seq的值是偶数，则读取数据成功。

值得注意的是，当读操作进入临界代码段时，无需禁止内核抢占。因为，我们允许写操作打断读操作的执行，这也是Seqlock锁写操作优先级高的设计初衷。但是，写操作进入临界代码段时，会自动禁止内核抢占。

# 4 seqlock锁使用场合

并不是所有的数据结构都能使用seqlock锁保护。因为seqlock锁有自身的缺点：因为写操作的优先级高于读操作，所以，对于写操作负荷比较的重的场合来说就不合适。如果写操作过于频繁，那么对读操作来说极为不公平，可能需要多次读取数据才能成功。所以，使用seqlock锁的场合应该满足下面的条件：

* 要保护的数据结构不能包含指针，而且这些指针写操作修改，读操作进行引用。因为可能写操作修改了指针，而读操作还会引用之前的指针。

* 要保护的数据结构必须是特别短小的代码，而且读操作比较频繁，写操作很少且非常快。（这也是读写自旋锁的使用原则）

* 读操作的临界代码段中的代码不能有副作用（否则，多次读操作可能与单次读取有不同的效果）。

典型应用可以参考linux内核关于系统时间处理的部分。等分析Linux内核关于系统时间的部分时，再详细阐述。
