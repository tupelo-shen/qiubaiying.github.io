---
layout:     post
title:      Linux内核36-内核同步之禁止中断
subtitle:   禁止中断作为同步手段的使用方法
date:       2020-04-19
author:     Tupelo Shen
header-img: img/post-bg-unix-linux.jpg
catalog:    true
tags:
    - Linux
    - Linux内核
    - 禁止中断
---

每一种技术的出现必然是因为某种需求。正因为人的本性是贪婪的，所以科技的创新才能日新月异。

今天，我们了解一下内核同步的最后一种方法，关闭中断。这是一种简单粗暴的方式，但行之有效。

# 1 禁止中断

作为嵌入式软件开发人员，对于禁止中断肯定不陌生。尤其是基于MCU的嵌入式软件，因为就一个微处理器核，所以禁止中断是实现临界代码段的有效手段。笔者比较熟悉的μC/OS-II或III，就是使用禁止中断保护临界代码段。当然了，这样的临界代码段一般较短，就几行代码而已。如果太长，会影响整个系统任务的调度，也有可能导致中断信号的丢失。

同样，Linux也不会放弃禁止中断这么好的同步机制。它保证内核控制路径可以继续执行，其访问的数据结构不会被中断处理程序破坏。但是，多核系统中，中断禁止是一个局部概念，也就是说，只是某一个CPU核中断被禁止，不能阻止运行在其它CPU上的中断处理程序访问要保护的数据结构。所以，在多核系统中，内核数据结构的保护一般是禁止中断搭配自旋锁一起使用。

local_irq_disable()利用cli汇编指令，禁止局部CPU的中断；local_irq_enable()利用sti汇编指令使能中断。正如在讲解"IRQ和中断"时所说的那样，cli和sti汇编指令，分别用来清除和设置eflags寄存器中的IF标志。

当内核代码进入临界代码段时，通过清除eflags寄存器中的IF标志实现禁止中断，从而保护临界代码段。但是，当内核离开临界代码段的时候，内核是否该恢复之前的IF标志呢？还是不做任何处理？显然，不做任何处理是不可以的，因为那样的话，就会丢失某些中断信号，这对于一个安全可靠的系统而言，是非常荒谬的。我们知道中断是以嵌套的方式被执行的，所以内核无需知道之前是什么具体的IF标志。只需要记录之前的标志值，在退出临界代码段的时候恢复之前的IF标志即可。

保存和恢复eflags内容，可以分别通过local_irq_save()和local_irq_restore()实现。local_irq_save拷贝eflags内容到一个局部变量中，然后调用cli指令清除IF标志。退出临界代码段的时候，local_irq_restore再把局部变量中的内容拷贝到eflags寄存器中。

# 2 禁止软中断

在讲软中断的时候，我们知晓可延时函数的执行时间是不可预测的（基本上都是在硬件中断处理程序终止的时候，因为软中断的实现大部分时候都是给tasklet服务的，而tasklet的用处就是协助硬件处理程序处理那些耗时长，又不是那么紧急的任务的）。因此，可延时函数要访问的数据结构必须被保护起来，防止竞态条件的产生。

可能很多人都想到了一个简单粗暴的方法，直接禁止那个CPU的中断不就可以了吗。没有中断处理程序被激活，软中断的行为也就不会发生混乱。

但是，事情不会那么简单，有时候，内核需要只禁止可延时函数，而不禁止中断。那怎么实现呢？

回忆do_softirq()函数，如果软中断计数器（存储在当前线程thread_info描述符的preempt_count成员中）是正数，它就不会处理软中断。所以，将这个计数器设为正数，软中断不会执行，在其上的所有可延时函数也不会执行。

local_bh_disable()给局部CPU的软中断计数器加1，local_bh_enable()则是将其减1。local_bh_disable()可以嵌套多调用几次，如果调用local_bh_enable()的次数匹配，可延时函数就会被使能。

为了确保及时执行长时间等待的线程，local_bh_enable()对软中断计数器执行减1操作之后，还有执行两个重要的操作：

1. 检查preempt_count中的硬中断计数器和软中断计数器。如果都是0，且有挂起的软中断要执行，直接调用do_softirq()激活它们。

2. 检查局部CPU的 TIF_NEED_RESCHED标志是否被设置；如果被设置，说明此时有进程正在请求调度，然后调用preempt_schedule()执行抢占调度。

# 3 总结

总之一句话，禁止中断包含禁止硬中断和软中断两种。禁止硬中断肯定就包含禁止软中断；但禁止软中断不会影响硬中断的响应。它们都有各自的使用场景。
